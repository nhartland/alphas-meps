#!/usr/bin/env python
# coding=utf-8
"""
Merges YODA files found in sub directories of the passed Analysis directory
generated by run.py.

This script is aware of the -p option of run.py and merges only YODA files
with the same tag value.

Merged YODA files will be written to the passed directory.
"""

import os
import sys
import subprocess
import re

import numpy as np


def main():
    """Entry point if this file is executed as a script."""
    root_dir = sys.argv[1]
    if len(sys.argv) > 2:
        prompted_tag_values = set(sys.argv[2].split(','))
    else:
        prompted_tag_values = None

    # get very first subdir, this might be of the form "Seed.n" or "Seed.n-m"
    # (where m might even be -1)
    first_seed_subdir = get_immediate_subdirectories(root_dir)[0]
    first_seed = first_seed_subdir.split('-')[0].split('.')[-1]

    # get values for m that have been used
    first_seed_subdirs = get_immediate_subdirectories(root_dir, regex='^Seed.' + first_seed + '(-[-0-9]+)?$')
    print first_seed_subdirs
    tag_values = set([''.join(subdir.split('-', 1)[1:]) for subdir in first_seed_subdirs])
    if prompted_tag_values is not None:
        tag_values = tag_values & prompted_tag_values  # use union of sets

    for tag_value in tag_values:
        suffix = '' if tag_value == '' else '-' + tag_value
        tag_value_subdirs = get_immediate_subdirectories(root_dir, regex='^Seed.\d+' + suffix + '$')
        combine_files(root_dir, tag_value_subdirs, suffix, 'yoda', combine_yodas)
        combine_files(root_dir, tag_value_subdirs, suffix, 'dat', combine_dats)


def combine_files(rootdir, subdirs, suffix, extension, combiner):
    for file_name in get_files(subdirs[0], extension):
        input_paths = [os.path.join(subdir, file_name) for subdir in subdirs]
        output_path = os.path.join(rootdir, os.path.splitext(file_name)[0]
                                   + suffix + os.path.splitext(file_name)[1])
        combiner(input_paths, output_path)


def combine_yodas(input_paths, output_path):
    command_parts = ['yodamerge', '-o', output_path] + input_paths
    subprocess.call(command_parts)


def combine_dats(input_paths, output_path):
    combined = None
    ycols = None
    header = None
    try:
        for input_path in input_paths:
            histo = np.loadtxt(input_path)
            if combined is None:
                combined = histo
                ycols = dat_ycolumns(input_path)
                header = dat_header(input_path)
            else:
                # add all columns in the right oder (except for the first one)
                for histo_idx, col in enumerate(dat_ycolumns(input_path)):
                    combined_idx = ycols.index(col)
                    combined[:, combined_idx + 1] += histo[:, histo_idx + 1]
    except IOError:
        print "Can not combine", output_path
        return
    np.savetxt(output_path, combined, header=header)


def dat_ycolumns(path):
    return dat_header(path).split()[1:]


def dat_header(path):
    header = ''
    with open(path) as f:
        header = f.readline()[1:].strip()
    return header


def get_immediate_subdirectories(a_dir, begin='', end='', regex=None):
    """Return list of a_dir's immediate subdirectories."""
    if regex is not None:
        p = re.compile(regex)
    else:
        p = re.compile('')
    return [os.path.join(a_dir, name) for name in os.listdir(a_dir)
            if os.path.isdir(os.path.join(a_dir, name))
            and name[:len(begin)] == begin
            and name[len(name) - len(end):] == end
            and p.match(name) is not None]


def get_files(a_dir, extension):
    """Return list of YODA files located in a_dir."""
    return [name for name in os.listdir(a_dir)
            if os.path.isfile(os.path.join(a_dir, name)) and name[-len(extension)-1:].lower() == '.' + extension]

if __name__ == "__main__":
    main()
